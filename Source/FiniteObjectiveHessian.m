function [H, D, G] = FiniteObjectiveHessian(m, con, obj, opts)
%ObjectiveHessian Evaluate the hessian of a set of objective functions by finite
%   difference approximation
%
% Usage:
%   1. Original way, 1st set of input args below. Single model with a
%      vector of conditions and matrix of objective functions, where all
%      conditions are derived from the model, and each row of objective
%      functions is derived from the corresponding condition row.
%	2. New way, 2nd set of input args below. Multiple models,
%      conditions, and objective function vectors, plus an options struct
%      generated by BuildFitOpts to create the desired mapping.
%
%   This function is identical to ObjectiveHessian except that the
%   gradient is calculated differently. This is useful for testing that
%   custom-made objective functions have been coded correctly and that
%   integration tolerances have been set appropriately.
%
% Inputs:
%	m [ model struct scalar | nModel x 1 model struct vector ]
%       The KroneckerBio model that will be simulated
% 	con [ nCon x 1 experiment struct vector | nCon x 1 experiment struct vector ]
%       The experimental conditions under which the model will be simulated
%	obj [ nCon x nCon objective struct matrix | nObj x 1 objective struct vector ]
%       The objective structures defining the objective functions to be
%       evaluated.
%	opts [ options struct scalar ]
%       Options struct with just global opts or detailed options from
%       BuildFitOpts.
%
% Outputs:
%   H [ nT x nT real matrix ]
%       The sum of all objective function hessians
%   D [ nT x 1 real vector ]
%       The sum of all objective function gradients
%   G [ scalar real ]
%       The objective function value

%% Work-up
% Clean up inputs
if nargin < 4
    opts = [];
end
if nargin < 4 || ~isfield(opts, 'fit')
    % Convert Usage 1 -> Usage 2
    [m, con, obj, opts] = ConvertFitOpts(m, con, obj, opts);
end
% opts.UseAdjoint = false; % adjoint methods not implemented for higher order sensitivities
verbose = logical(opts.Verbose);

% Store starting parameter sets
T0 = collectAllActiveParameters(m, con, opts.fit.ComponentMap, opts.fit.Tlocal2T);

%% Loop through conditions
nT = length(T0);
H = zeros(nT,nT);

% Initial value
if verbose; fprintf('Initial round\n'); end
[G, D] = computeObjAll(m, con, obj, opts, 'grad');

for iT = 1:nT
    if verbose; fprintf('Step %d of %d\n', iT, nT); end
    
    % Set baseline parameters
    T_i = T0(iT);
    T_up = T0;
    
    % Change current parameter by finite amount
    step_size = 1e-8; 
    if opts.Normalized
        norm_factor = T_i;
    else
        norm_factor = 1;
    end
    if opts.ComplexStep
        imag_factor = 1i;
    else
        imag_factor = 1;
    end
    diff = step_size * norm_factor * imag_factor;
    
    % Compute D
    T_up(iT) = T_up(iT) + diff;
    [m, con] = updateAllActiveParameters(m, con, T_up, opts.fit.ComponentMap, opts.fit.T2Tlocal);
    [~, D_up] = computeObjAll(m, con, obj, opts, 'grad');

    % Compute H
    if opts.ComplexStep
        H(:,iT) = imag(D_up) ./ step_size;
    else
        H(:,iT) = (D_up - D) ./ step_size;
    end
end
