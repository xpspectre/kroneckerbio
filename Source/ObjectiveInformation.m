function [F, All] = ObjectiveInformation(m, con, obj, opts, dxdTSol)
%ObjectiveInformation Compute the Fisher information matrix (FIM) of a set of
%   objective functions
%
%   Mathematically: F = E(d2logpdT2(y,Y), y, p_y|T(y,T))
%
% Usage:
%   [F, All] = ObjectiveInformation(m, con, obj, opts)
%   [F, All] = ObjectiveInformation(m, con, obj, opts, dxdTSol)
%
% Specification of input args:
%   1. Original way, 1st set of input args below. Single model with a
%      vector of conditions and matrix of objective functions, where all
%      conditions are derived from the model, and each row of objective
%      functions is derived from the corresponding condition row.
%	2. New way, 2nd set of input args below. Multiple models,
%      conditions, and objective function vectors, plus an options struct
%      generated by BuildFitOpts to create the desired mapping.
%
% Inputs:
%	m [ model struct scalar | nModel x 1 model struct vector ]
%       The KroneckerBio model that will be simulated
% 	con [ nCon x 1 experiment struct vector | nCon x 1 experiment struct vector ]
%       The experimental conditions under which the model will be simulated
%	obj [ nCon x nCon objective struct matrix | nObj x 1 objective struct vector ]
%       The objective structures defining the objective functions to be
%       evaluated.
%	opts [ options struct scalar ]
%       Options struct with just global opts or detailed options from
%       BuildFitOpts.
%       The particular objective function evaluation desired.
%   dxdTSol [ nCon x 1 cell array of sensitivity solution structs {} ]
%       Optional sensitivity solution struct(s) from
%       integrateAllSens if you don't want to recalculate them
%       in this function. The number and ordering of structs
%       must match those in con/opts.
%
% Outputs:
%   F [ double matrix ]
%       Combined fisher information matrix. The FIM is the sum of all
%       fisher information matrices assuming there is no
%       covariance between errors in seperate experiments.
%   FAll [ nCon x 1 cell array of double matrices ]
%       The individual FIMs for each experiment

%% Work-up
% Clean up inputs
if nargin < 5
    dxdTSol = [];
    if nargin < 4
        opts = [];
    end
end

if isempty(opts) || ~isfield(opts, 'fit')
    % Convert Usage 1 -> Usage 2
    [m, con, obj, opts] = ConvertFitOpts(m, con, obj, opts);
end

% Corner case of no conditions
if isempty(con) % length(con) == 0
    F = 0;
    All = {};
    return
end

%% Run main calculation
[F, All] = computeObjAll(m, con, obj, opts, 'info', dxdTSol);
